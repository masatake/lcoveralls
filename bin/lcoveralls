#!/usr/bin/ruby -w

# Copyright 2014 Paul Colby

require 'find'
require 'json'
require 'net/http'
require 'optparse'

# @todo Set this via rake?
VERSION = '0.0.1'

options = {}

opts = OptionParser.new do |o|
  o.banner = "Usage: #{o.program_name} [options] [tracefile(s)]"
  o.on('-h', '--help',        'Print usage text, then exit')     { puts o; exit }
  o.on('-r', '--root PATH',   'Set the path to the repo root')   { |path|  options[:root]  = path  }
  o.on('-s', '--service NAME','Set coveralls service name')      { |name|  options[:service] = name }
  o.on('-t', '--token TOKEN', 'Set coveralls repo token')        { |token| options[:token] = token }
  o.on('-v', '--version',     'Print version number, then exit') { puts VERSION; exit }
end

begin
opts.parse!
rescue OptionParser::InvalidOption => e
  $stderr.puts opts
  $stderr.puts e
  exit 1
end

def find_root(info_files)
  # Try source file(s) covered by the lcov tracefile(s).
  root_dirs = Hash.new(0)
  info_files.each do |file|
    File.open(file).each do |line|
      line.match(/^SF:(.*)$/) do |match|
        Dir.chdir(File.dirname(match[1])) do
          root_dir = `git rev-parse --show-toplevel`.rstrip
          root_dirs[root_dir] = root_dirs[root_dir] + 1 unless root_dir.empty?
        end if Dir.exist?(File.dirname(match[1]))
      end
    end
  end

  if root_dirs.empty?
    nil
  elsif root_dirs.size == 1
    root_dirs.shift[0]
  else
    root_dir = root_dirs.max_by { |key, value| value }[0]
    warn "Warning: Found multiple possible repo roots. Settled on #{root_dir}"
    root_dir
  end
end

def get_source_files(info_files, root_dir)
  sources = {}
  info_files.each do |file|
    source_pathname = nil
    in_record = false
    File.open(file).each do |line|
      # SF:<absolute path to the source file>
      line.match('^SF:' + Regexp.quote(root_dir) + '/(.*)$') do |match|
        warn 'Warning: Found source filename without preceding end_of_record' if in_record
        source_pathname = match[1]
        if !sources.has_key?(source_pathname) then
          source = File.read(match[1])
          sources[source_pathname] = {
            :name => source_pathname,
            :source => source,
            :coverage => Array.new(source.lines.count)
          }
        end
      end

      # DA:<line number>,<execution count>[,<checksum>]
      line.match(/DA:(?<line>\d+),(?<count>\d+)(,(?<checksum>.*))?$/) do |match|
        line_index = match[:line].to_i - 1
        if !sources[source_pathname][:coverage][line_index] then
          sources[source_pathname][:coverage][line_index] = 0
        end
        sources[source_pathname][:coverage][line_index] = 
          sources[source_pathname][:coverage][line_index] + match[:count].to_i;
      end

      # end_of_record
      in_record = false if line == "end_of_record\n"
    end
  end

  sources.values
end

def get_git_info(root_dir)
  Dir.chdir(root_dir) do
    info = {}

    info[:head] = {}
    info[:head][:id] = `git show --format='%H' --no-patch`.rstrip
    info[:head][:author_name] = `git show --format='%an' --no-patch`.rstrip
    info[:head][:author_email] = `git show --format='%ae' --no-patch`.rstrip
    info[:head][:commiter_name] = `git show --format='%cn' --no-patch`.rstrip
    info[:head][:commiter_email] = `git show --format='%ce' --no-patch`.rstrip
    info[:head][:message] = `git show --format='%B' --no-patch`.rstrip

    info[:branch] = `git rev-parse --abbrev-ref HEAD`.rstrip

    info[:remotes] = []
    `git remote --verbose`.each_line do |line|
      line.match(/^(?<name>\S+)\s+(?<url>\S+)(\s+\((fetch|push)\))?/) do |match|
        info[:remotes] << Hash[match.names.zip(match.captures)]
      end
    end
    info[:remotes].uniq!
    info.delete(:remotes) if info[:remotes].empty?

    info
  end if Dir.exist?(root_dir)
end

begin

  # Find *.info tracefiles if none specified on the command line.
  Find.find('.') do |path|
    ARGV << path if path =~ /.*\.info$/
  end unless ARGV.any?

  options[:root] = find_root(ARGV) unless options.include?(:root)
  abort 'Error: No root specified, and none could be detected.' unless options[:root]

  job = {}
  job[:repo_token] = options[:token]
  job[:service_name] = 'lcoveralls' # @todo Use CLI and/or ENV.
  #job[:service_job_id] = '1' # TRAVIS_JOB_NUMBER

  job[:source_files] = get_source_files(ARGV, options[:root])
  job[:git] = get_git_info(options[:root])
  job[:run_at] = Time.new

#  puts JSON::pretty_generate job

  uri = URI('https://coveralls.io/api/v1/jobs')
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_PEER

  BOUNDARY = '--' + File.basename($0) + '-' + VERSION + '--'
  req = Net::HTTP::Post.new(uri.path)
  req.content_type = "multipart/form-data, boundary=#{BOUNDARY}"
  req.body =
    "--#{BOUNDARY}\r\n" +
    "Content-Disposition: form-data; name=\"json_file\"; filename=\"json_file\"\r\n" +
    "Content-Type: application/json\r\n\r\n" +
    JSON::generate(job) + "\r\n\r\n--#{BOUNDARY}--\r\n"

  res = http.request(req)
  puts res.body
end
