#!/usr/bin/ruby -w

# Copyright 2014 Paul Colby

require 'find'
require 'json'
require 'optparse'

# @todo Set this via rake?
VERSION = '0.0.1'

options = {}

opts = OptionParser.new do |o|
  o.banner = "Usage: #{o.program_name} [options] [tracefile(s)]"
  o.on('-h', '--help',        'Print usage text, then exit')     { puts o; exit }
  o.on('-r', '--root PATH',   'Set the path to the repo root.')  { |path|  options[:root]  = path  }
  o.on('-t', '--token TOKEN', 'Set coveralls repo token')        { |token| options[:token] = token }
  o.on('-v', '--version',     'Print version number, then exit') { puts VERSION; exit }
end

begin
opts.parse!
rescue OptionParser::InvalidOption => e
  $stderr.puts opts
  $stderr.puts e
  exit 1
end

def find_root(info_files)
  # Try source file(s) covered by the lcov tracefile(s).
  root_dirs = Hash.new(0)
  info_files.each do |file|
    File.open(file).each do |line|
      line.match(/^SF:(.*)$/) do |match|
        Dir.chdir(File.dirname(match[1])) do
          root_dir = `git rev-parse --show-toplevel`.rstrip
          root_dirs[root_dir] = root_dirs[root_dir] + 1 unless root_dir.empty?
        end if Dir.exist?(File.dirname(match[1]))
      end
    end
  end

  if root_dirs.empty?
    nil
  elsif root_dirs.size == 1
    root_dirs.shift[0]
  else
    root_dir = root_dirs.max_by { |key, value| value }[0]
    warn "Warning: Found multiple possible repo roots. Settled on #{root_dir}"
    root_dir
  end
end

def get_source_files(info_files, root_dir)
  sources = {}
  info_files.each do |file|
    source_pathname = nil
    in_record = false
    File.open(file).each do |line|
      # SF:<absolute path to the source file>
      # DA:<line number>,<execution count>[,<checksum>]
      # end_of_record
      #line.match(/^SF:(.*)$/) do |match|
      #  warn 'Warning: Found source filename without preceding end_of_record' if in_record
      #  source_pathname = match[1]
      #  if (source_pathname.start_with?(root_dir)) then
      #    sources[source_pathname] = {} unless sources.has_key?(source_pathname)
      #    sources[source_pathname][:name] = source_pathname.sub(root_dir+'/', '')
      #  end
      #end

      line.match('^SF:' + Regexp.quote(root_dir) + '/(.*)$') do |match|
        warn 'Warning: Found source filename without preceding end_of_record' if in_record
        source_pathname = match[1]
        sources[source_pathname] = {} unless sources.has_key?(source_pathname)
        sources[source_pathname][:name] = source_pathname
      end

      in_record = false if line == "end_of_record\n"
    end
  end

  sources.values
end

def get_git_info(root_dir)
  Dir.chdir(root_dir) do
    info = {}

    info[:head] = {}
    info[:head][:id] = `git show --format='%H' --no-patch`.rstrip
    info[:head][:author_name] = `git show --format='%an' --no-patch`.rstrip
    info[:head][:author_email] = `git show --format='%ae' --no-patch`.rstrip
    info[:head][:commiter_name] = `git show --format='%cn' --no-patch`.rstrip
    info[:head][:commiter_email] = `git show --format='%ce' --no-patch`.rstrip
    info[:head][:message] = `git show --format='%B' --no-patch`.rstrip

    info[:branch] = `git rev-parse --abbrev-ref HEAD`.rstrip

    info[:remotes] = []
    `git remote --verbose`.each_line do |line|
      line.match(/^(\S+)\s+(\S+)(?:\s+\((fetch|push)\))?/) do |match|
        info[:remotes] << { 'name' => match[1], 'url' =>  match[2] }
      end
    end
    info[:remotes].uniq!
    info.delete(:remotes) if info[:remotes].empty?

    info
  end if Dir.exist?(root_dir)
end

begin

  # Find *.info tracefiles if none specified on the command line.
  Find.find('.') do |path|
    ARGV << path if path =~ /.*\.info$/
  end unless ARGV.any?

  options[:root] = find_root(ARGV) unless options.include?(:root)
  abort 'Error: No root specified, and none could be detected.' unless options[:root]

  job = {}
  job[:repo_token] = '@todo'
  job[:service_name] = '@todo'   # 'travis'
  job[:service_job_id] = '@todo' # TRAVIS_JOB_NUMBER

  job[:source_files] = get_source_files(ARGV, options[:root])
  job[:git] = get_git_info(options[:root])
  job[:run_at] = Time.new

  puts options
  puts ARGV
  puts JSON::pretty_generate job
end
