#!/usr/bin/ruby -w

# Copyright 2014 Paul Colby

# @todo FOSS license goes here.

# Include our lib path, if not already.
lib_path = File.join(File.dirname(File.dirname(File.realpath(__FILE__))), 'lib')
$LOAD_PATH.unshift(lib_path) unless $LOAD_PATH.include?(lib_path)

require 'find'
require 'json'
require 'net/http'
require 'optparse'
require 'lcoveralls'

# @todo Set this via rake?
VERSION = '0.0.1'

# @todo Better name for this class.  Maybe within a module?
class Lcoverallsx

def parse_options
    @options = { :verbosity => 1 }
  opts = OptionParser.new do |o|
    o.banner = "Usage: #{o.program_name} [options] [tracefile(s)]"
    o.summary_width = 20
    o.separator ''

    o.separator 'Code / coveralls.io options:'
    o.on(      '--dryrun',      'Do not actually submit to coveralls.io' ) { @options[:dryrun] = true }
    o.on('-r', '--root PATH',   'Set the path to the repo root')   { |path|  @options[:root]  = path  }
    o.on('-s', '--service NAME','Set coveralls service name')      { |name|  @options[:service] = name }
    o.on('-t', '--token TOKEN', 'Set coveralls repo token')        { |token| @options[:token] = token }
    o.separator ''

    o.separator 'Logging options:'
    o.on(      '--silent',      'Disable all standard output') { @options[:verbosity] = 0 }
    o.on('-q', '--quiet',       'Show less standard output')   { @options[:verbosity] = @options[:verbosity] - 1 }
    o.on('-v', '--quiet',       'Show more standard output')   { @options[:verbosity] = @options[:verbosity] + 1 }
    o.on(      '--trace',       'Show as much output as possible') { @options[:verbosity] = 1000 }
    o.separator ''

    o.separator 'Miscellaneous options:'
    o.on('-h', '--help',        'Print usage text, then exit')     { puts o; exit }
    o.on(      '--version',     'Print version number, then exit') { puts VERSION; exit }
    o.separator ''
  end

  begin
    opts.parse!
    @log = Logger.new(STDERR)
    @log.formatter = Lcoveralls::ColorFormatter.new # @todo Apply --color option.
  rescue OptionParser::InvalidOption => e
    $stderr.puts opts
    $stderr.puts e
    exit 1
  end
end

def find_root(info_files)
  # Try source file(s) covered by the lcov tracefile(s).
  root_dirs = Hash.new(0)
  info_files.each do |file|
    File.open(file).each do |line|
      line.match(/^SF:(.*)$/) do |match|
        Dir.chdir(File.dirname(match[1])) do
          root_dir = `git rev-parse --show-toplevel`.rstrip
          root_dirs[root_dir] = root_dirs[root_dir] + 1 unless root_dir.empty?
        end if Dir.exist?(File.dirname(match[1]))
      end
    end
  end

  if root_dirs.empty?
    nil
  elsif root_dirs.size == 1
    root_dirs.shift[0]
  else
    root_dir = root_dirs.max_by { |key, value| value }[0]
    warn "Warning: Found multiple possible repo roots. Settled on #{root_dir}"
    root_dir
  end
end

def get_source_files(info_files, root_dir)
  sources = {}
  info_files.each do |file|
    source_pathname = nil
    in_record = false
    File.open(file).each do |line|
      # SF:<absolute path to the source file>
      line.match('^SF:' + Regexp.quote(root_dir) + '/(.*)$') do |match|
        warn 'Warning: Found source filename without preceding end_of_record' if in_record
        source_pathname = match[1]
        if !sources.has_key?(source_pathname) then
          source = File.read(match[1])
          sources[source_pathname] = {
            :name => source_pathname,
            :source => source,
            :coverage => Array.new(source.lines.count)
          }
        end
      end

      # DA:<line number>,<execution count>[,<checksum>]
      line.match(/DA:(?<line>\d+),(?<count>\d+)(,(?<checksum>.*))?$/) do |match|
        line_index = match[:line].to_i - 1
        if !sources[source_pathname][:coverage][line_index] then
          sources[source_pathname][:coverage][line_index] = 0
        end
        sources[source_pathname][:coverage][line_index] = 
          sources[source_pathname][:coverage][line_index] + match[:count].to_i;
      end

      # end_of_record
      in_record = false if line == "end_of_record\n"
    end
  end

  sources.values
end

def get_git_info(root_dir)
  Dir.chdir(root_dir) do
    info = {}

    info[:head] = {}
    info[:head][:id] = `git show --format='%H' --no-patch`.rstrip
    info[:head][:author_name] = `git show --format='%an' --no-patch`.rstrip
    info[:head][:author_email] = `git show --format='%ae' --no-patch`.rstrip
    info[:head][:commiter_name] = `git show --format='%cn' --no-patch`.rstrip
    info[:head][:commiter_email] = `git show --format='%ce' --no-patch`.rstrip
    info[:head][:message] = `git show --format='%B' --no-patch`.rstrip

    info[:branch] = `git rev-parse --abbrev-ref HEAD`.rstrip

    info[:remotes] = []
    `git remote --verbose`.each_line do |line|
      line.match(/^(?<name>\S+)\s+(?<url>\S+)(\s+\((fetch|push)\))?/) do |match|
        info[:remotes] << Hash[match.names.zip(match.captures)]
      end
    end
    info[:remotes].uniq!
    info.delete(:remotes) if info[:remotes].empty?

    info
  end if Dir.exist?(root_dir)
end

# Note, 0-73 is valid for MIME, but only 0-61 is valid for HTTP headers.
def boundary_chr(index)
  case index
  when 0..9
    index.to_s
  when 10..35
    ('a'.ord + index - 10).chr
  when 36..61
    ('A'.ord + index - 36).chr
  when 62..73
    "'()+_,-./:=?"[index - 62]
  else
    @log.error "Invalid boundary index #{index}"
    exit!
  end
end

def run
  # Find *.info tracefiles if none specified on the command line.
  Find.find('.') do |path|
    puts "Looking for tracefiles: #{path}" if @options[:verbosity] > 2
    if path =~ /.*\.info$/ then
      puts "Found tracefile: #{path}" if @options[:verbosity] > 1
      ARGV << path
    end
  end unless ARGV.any?

  @options[:root] = find_root(ARGV) unless @options.include?(:root)
  if !@options[:root] then
    @log.error 'No root specified, and none could be detected.'
    exit!
  end

  # @todo  travis-ci environment vars.
  job = {}
  job[:repo_token] = @options[:token]
  job[:service_name] = 'lcoveralls' # @todo Use CLI and/or ENV.
  #job[:service_job_id] = '1' # TRAVIS_JOB_NUMBER

  job[:source_files] = get_source_files(ARGV, @options[:root])
  job[:git] = get_git_info(@options[:root])
  job[:run_at] = Time.new

  # @todo  Explicit CLI option for this.
  if @options[:verbosity] > 2 then
    puts JSON::pretty_generate job
  end

  # @todo All this HTTPS stuff can go into a separate class?
  uri = URI('https://coveralls.io/api/v1/jobs')
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_PEER

  @BOUNDARY = (1...70).map { boundary_chr(rand(62)) }.join
  req = Net::HTTP::Post.new(uri.path)
  req.content_type = "multipart/form-data, boundary=#{@BOUNDARY}"
  req.body =
    "--#{@BOUNDARY}\r\n" +
    "Content-Disposition: form-data; name=\"json_file\"; filename=\"json_file\"\r\n" +
    "Content-Type: application/json\r\n\r\n" +
    JSON::generate(job) + "\r\n--#{@BOUNDARY}--\r\n"

  if !@options[:dryrun] then
    res = http.request(req)
    puts res.body if res
  end
  
  #@log.debug { 'done in ' + { Time.new - @start_time } + ' seconds' }
end

end

begin
  lcoveralls = Lcoverallsx.new
  lcoveralls.parse_options
  lcoveralls.run
end
