#!/usr/bin/ruby -w

# Copyright 2014 Paul Colby

# @todo FOSS license goes here.

# Include our lib path, if not already.
lib_path = File.join(File.dirname(File.dirname(File.realpath(__FILE__))), 'lib')
$LOAD_PATH.unshift(lib_path) unless $LOAD_PATH.include?(lib_path)

require 'find'
require 'json'
require 'net/http'
require 'optparse'
require 'lcoveralls'

# @todo Set this via rake?
VERSION = '0.0.1'

# @todo Better name for this class.  Maybe within a module?
class Lcoverallsx

  def initialize
    # Parse the command line options.
    parser = Lcoveralls::OptionParser.new
    @options = parser.parse! ARGV

    # Setup a logger instance.
    @log = Logger.new(STDERR)
    @log.formatter = Lcoveralls::ColorFormatter.new @options[:color]
    @log.sev_threshold = @options[:severity]
    @log.debug { "Options: #{@options}" }
  end


def find_root(info_files)
  # Try source file(s) covered by the lcov tracefile(s).
  root_dirs = Hash.new(0)
  info_files.each do |file|
    File.open(file).each do |line|
      line.match(/^SF:(.*)$/) do |match|
        Dir.chdir(File.dirname(match[1])) do
          root_dir = `git rev-parse --show-toplevel`.rstrip
          root_dirs[root_dir] = root_dirs[root_dir] + 1 unless root_dir.empty?
        end if Dir.exist?(File.dirname(match[1]))
      end
    end
  end

  if root_dirs.empty?
    nil
  elsif root_dirs.size == 1
    root_dirs.shift[0]
  else
    root_dir = root_dirs.max_by { |key, value| value }[0]
    warn "Warning: Found multiple possible repo roots. Settled on #{root_dir}"
    root_dir
  end
end

def get_source_files(info_files, root_dir)
  sources = {}
  info_files.each do |file|
    source_pathname = nil
    in_record = false
    File.open(file).each do |line|
      # SF:<absolute path to the source file>
      line.match('^SF:' + Regexp.quote(root_dir) + '/(.*)$') do |match|
        warn 'Warning: Found source filename without preceding end_of_record' if in_record
        source_pathname = match[1]
        if !sources.has_key?(source_pathname) then
          source = File.read(match[1])
          sources[source_pathname] = {
            :name => source_pathname,
            :source => source,
            :coverage => Array.new(source.lines.count)
          }
        end
      end

      # DA:<line number>,<execution count>[,<checksum>]
      line.match(/DA:(?<line>\d+),(?<count>\d+)(,(?<checksum>.*))?$/) do |match|
        line_index = match[:line].to_i - 1
        if !sources[source_pathname][:coverage][line_index] then
          sources[source_pathname][:coverage][line_index] = 0
        end
        sources[source_pathname][:coverage][line_index] = 
          sources[source_pathname][:coverage][line_index] + match[:count].to_i;
      end

      # end_of_record
      in_record = false if line == "end_of_record\n"
    end
  end

  sources.values
end

def get_git_info(root_dir)
  Dir.chdir(root_dir) do
    info = {}

    info[:head] = {}
    info[:head][:id] = `git show --format='%H' --no-patch`.rstrip
    info[:head][:author_name] = `git show --format='%an' --no-patch`.rstrip
    info[:head][:author_email] = `git show --format='%ae' --no-patch`.rstrip
    info[:head][:commiter_name] = `git show --format='%cn' --no-patch`.rstrip
    info[:head][:commiter_email] = `git show --format='%ce' --no-patch`.rstrip
    info[:head][:message] = `git show --format='%B' --no-patch`.rstrip

    info[:branch] = `git rev-parse --abbrev-ref HEAD`.rstrip

    info[:remotes] = []
    `git remote --verbose`.each_line do |line|
      line.match(/^(?<name>\S+)\s+(?<url>\S+)(\s+\((fetch|push)\))?/) do |match|
        info[:remotes] << Hash[match.names.zip(match.captures)]
      end
    end
    info[:remotes].uniq!
    info.delete(:remotes) if info[:remotes].empty?

    info
  end if Dir.exist?(root_dir)
end

def run
  # Find *.info tracefiles if none specified on the command line.
  Find.find('.') do |path|
    @log.trace { "Looking for tracefiles: #{path}" }
    if path =~ /.*\.info$/ then
      @log.info { "Found tracefile: #{path}" }
      ARGV << path
    end
  end unless ARGV.any?

  @options[:root] = find_root(ARGV) unless @options.include?(:root)
  if !@options[:root] then
    @log.error 'No root specified, and none could be detected.'
    exit!
  end

  # Build the coveralls.io job request.
  job = {}
  job[:repo_token] = @options[:token] if @options.has_key? :token
  job[:service_name] = @options[:service] if @options.has_key? :service
  job[:service_job_id] = @options[:job_id] if @options.has_key? :job_id
  if !job.has_key?(:token) and !job.has_key?(:service_job_id) then
    @log.warn { 'No service job id detected; consider using --token' }
  end
  job[:source_files] = get_source_files(ARGV, @options[:root])
  job[:git] = get_git_info(@options[:root])
  job[:run_at] = Time.new
  request = Lcoveralls::CoverallsRequest.new(job)
  @log.trace { request.body }

  # @todo  Explicit CLI option for this.
  #@log.debug { JSON::pretty_generate job }

  # @todo All this HTTPS stuff can go into a separate class?
  uri = URI('https://coveralls.io/api/v1/jobs')
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_PEER

  if !@options[:dryrun] then
    @log.info {"Sending request" } # @todo include job_id (if any) and request size.
    res = http.request(request)
    puts res.body if res
  end
end

end

lcoveralls = Lcoverallsx.new
lcoveralls.run
